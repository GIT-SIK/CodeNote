■ STREAM
생성 -> 중간 연산 -> 최종 연산 -> 결과

■■■■■■■■■■■■■■■■■■■■■■■■ Stream Add ■■■■■■■■■■■■■■■■■■■■■■■■
- Arrays : 배열
  * e : Arrays.stream(arr)....

- Collection, List, Set
  * LIST e : ls.stream()...
  * Map e :
    > map.values().stream()...
    > map.keySet().stream()...
    > map.entrySet().stream()... .getKey() .getValue()
- Empty

- Stream.builder() :스트림 생성 (요소 추가(add))
   * e :
    Stream.Builder<String> builder = Stream.builder();
    builder.add("A");
    builder.add("B");

- Stream.generate() : 무한스트림 생성
   * e : Stream.generate(() -> "A")...

- Stream.iterate() : 초기값과 UnaryOperator 로 연속적인 요소를 생성함.
   * e : Stream.iterate(1, n -> n + 1)...

- String, Chars() : 문자열
  * e : "".chars()...

- Files

- Parallel <-> Sequential

- Stream.concat() : 두 스트림을 결합함.
   * 형식 : static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)




■■■■■■■■■■■■■■■■■■■■■■■■ Intermediate (중간연산) ■■■■■■■■■■■■■■■■■■■■■■■■
 - map : 요소 값 변경 (입력 T 타입 요소를 R 타입 요소로 변환)
   * map : 기본 -> 기본 / 객체 -> 객체
   * mapToObj : 기본타입 -> 객체타입
   * mapToInt : 객체 -> 기본(Int)
    > String은 객체타입으로 인식
 - boxed : [단순] 기본 -> 객체
 - flatMap : 평탄화 -> 단일 변환
 - filter : 조건 적용
 - skip	: n번째 요소까지 무시
 - limit : n번째 요소까지 출력
 - distinct	: 중복 제거
 - sorted : 정렬 (opt : Comparator.reverseOrder())
 - peek	: 중간 요소 확인
 - Collectors.toList()


■■■■■■■■■■■■■■■■■■■■■■■■ Result (결과) ■■■■■■■■■■■■■■■■■■■■■■■■
- Calculating : 요소 계산
  * sum()
  * average()
  * count()
  * max()
  * min()

- Reduction  : 각 요소를 모두 연산하여 하나의 결과로 만듦
  * reduce()

- Collecting : 요소를 수집 후 다른 컬렉션 및 데이터 구조화
  * collect()
    > Collectors.toArray()
    > Collectors.toList()
    > Collectors.toMap()
    > Collectors.joining()
    > Collectors.summarizingInt()
    > Collectors.summarizingLong()
    > Collectors.summarizingDouble()
    > Collectors.groupingBy()
    > Collectors.partitioningBy()

  * toArray()

- Matching : 검색 및 매칭
  * anyMatch()
  * allMatch()
  * noneMatch()
  * findAny()
  * findFirst()

- Iterating : 각 요소를 연산에 사용 후 소모
  * forEach()

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
 * 메서드 레퍼런스 연산자
 객체::메소드 -> 왼쪽 객체의 오른쪽 메소드 사용 (따로 괄호 필요없음)

  class A{
      int b;
      public int getB(){
        return b;
      }
  }

 레퍼런스 : A::getB

 1. 정적 메서드 레퍼런스
 람다 : Function<String, Integer> lambda = s -> Integer.parseInt(s);
 레퍼런스 : Function<String, Integer> reference = Integer::parseInt

 2. 인스턴스 메서드 레퍼런스
 람다 : Function<String, Integer> lambda = s -> s.length();
 레퍼런스 : Function<String, Integer> reference = String::length;

 3. 생성자 레퍼런스
 람다 : Supplier<List<String>> lambda = () -> new ArrayList<>();
 레퍼런스 : Supplier<List<String>> reference = ArrayList::new;
